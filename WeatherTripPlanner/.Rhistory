# return (png)
}
plotstock()
plotstock <- function(stock_symbol = "IMGN", year = "2022", file_name = "IMGN_2022"){
start_date <- paste0(year, "-01-01")
end_date <- paste0(year, "-12-31")
png(file_name)
getSymbols(stock_symbol,
auto.assign = TRUE,
from = start_date,
to = end_date)
stock_year <- chart_Series(Ad(get(noquote(stock_symbol))))
dev.off()
return(stock_year)
}
plotstock()
install.packages("shiny")
library (shiny)
runApp('Desktop/PIPS/shiny_example.R')
runApp('Desktop/PIPS/shiny_example_widget.R')
titanic
ChickWeight
ChickWeight
Orange
cars
titanic
titanic_train
Titanic
runApp('Desktop/PIPS/assignments/shiny_datasets.R')
runApp('Desktop/PIPS/assignments/shiny_datasets.R')
ChickWeight
runApp('Desktop/PIPS/assignments/shiny_datasets.R')
ChickWeight
ui <- fluidPage(
titlePanel("Datasets for PIPS Assignments"),
sidebarLayout(
# Sidebar panel for inputs
sidebarPanel(
# Input: Select a dataset
selectInput("dataset", "Choose a dataset:",
choices = c("Trees", "Orange","ToothGrowth",
"ChickWeight", "Cars", "Titanic")),
# Input: Specify the number of observations to view
numericInput("obs", "Number of observations to view:", 10),
# Include clarifying text
helpText("Note: The summary is based on the full dataset",
"independent of indicated number of observations"),
# Input: actionButton() to defer the rendering of output
# until the user explicitly clicks the button.
actionButton("update", "Update View")
),
# Main panel for displaying outputs
mainPanel(
# Output: Header + summary of distribution
h4("Summary"),
verbatimTextOutput("summary"),
# Output: Header + table of distribution
h4("Observations"),
tableOutput("view")
)
)
)
d=data.frame(sex=c("m","f"),nr=1:40,score1=rnorm(40,0.5,1),score2=rnorm(40))
t.test?
?t.test
set.seed(1)
d=data.frame(sex=c("m","f"),nr=1:40,score1=rnorm(40,0.5,1),score2=rnorm(40))
# Subset the data for men and women
men_scores <- d$score1[d$sex == "m"]
women_scores <- d$score1[d$sex == "f"]
# Perform one-sided t-test
t_test_result <- t.test(men_scores, women_scores, alternative = "greater")
# Print the test result
print(t_test_result)
# Perform t-test using general linear model approach
t_test_result <- t.test(score1 ~ 1 + sex, data = d, alternative = "greater")
# Print the test result
print(t_test_result)
# Perform t-test using general linear model approach
t_test_result <- t.test(score1 ~ 1 + sex, data = d, alternative = "less")
# Print the test result
print(t_test_result)
t.test(score1 ~ sex,alternative="less", data=d)
t.test(score1 ~ sex,alternative="less", data=d)
t.test(score1 ~ sex,alternative="less", data=d)
data = c(36,40,47,53,26,45,52,38,46,44,36,54,54,49,57,47,29,36,29,37)
t.test(d$score1, d$score2,alternative="two.sided")
t.test(d$score1, d$score2,alternative="two.sided")
t.test(d$score1, d$score2,alternative="two.sided")
mean(data)
sd(data)
qt(data)
length(data)
qt(0.975, df = length(data) - 1)
(se*t(0.975))
t = qt(0.975, df = length(data) - 1)
se*t(0.975)
standard_deviation <- sd(data)
## Calculate the sample size
sample_size <- length(data)
## Calculate the standard error
SE <- standard_deviation / sqrt(sample_size)
## Calculate the margin of error using the critical t-value
critical_t_value <- qt(0.975, df = sample_size - 1)
margin_of_error <- SE * critical_t_value
sample_mean <- mean(data)
# Calculate the lower bound of the confidence interval
lower_bound <- sample_mean - margin_of_error
# Calculate the upper bound of the confidence interval
upper_bound <- sample_mean + margin_of_error
a <- t(x) * x
x <- c(3,4,6,8,8)
a <- t(x) * x
a
x_1 <- c(3,4,6,8,8)
x_2 <- c(2,6,4,7,7)
y <- c(4,3,5,6,9)
X_matrix <- matrix(cbind(rep(1,5), x_1, x_2), ncol = 3)
X <- matrix(cbind(rep(1,5), x_1, x_2), ncol = 3)
t(X) * X
x_1 <- c(3,4,6,8,8)
x_2 <- c(2,6,4,7,7)
y <- c(4,3,5,6,9)
X <- matrix(cbind(rep(1,5), x_1, x_2), ncol = 3)
t(X) %*% X
t(X) %*% y
XTX <- t(X) %*% X
XTY <- t(X) %*% y
beta <- slove(XTX) %*% XTY
beta <- solve(XTX) %*% XTY
beta
health <- read.table("health.txt", header = TRUE)
health <- read.table("health.txt", header = TRUE)
fit <- lm(y ~ x_1 + x_2)
fit
summary(fit)
predict(fit)
yhat <- predict(fit)
s2 <- (t(y-yhat) %*% (y-yhat))
s2
sqrt
sqrt(s2)
s2 <- (t(y-yhat) %*% (y-yhat)) / (5-2-1)
sqrt(s2)
set.seed(1)
d=data.frame(sex=c("m","f"),nr=1:40,score1=rnorm(40,0.5,1),score2=rnorm(40))
View(d)
t.test(d$score1[d$sex == "m"],d$score1[d$sex == "f"], alternative = "greater")
t.test(score1 ~sex, data = d)
t.test(score1 ~sex, alternative = "less", data = d)
t.test(d$score1, d$score2, alternative = "equal")
t.test(d$score1, d$score2)
data = c(36,40,47,53,26,45,52,38,46,44,36,54,54,49,57,47,29,36,29,37)
data = c(36,40,47,53,26,45,52,38,46,44,36,54,54,49,57,47,29,36,29,37)
mean(data)
sd(data)
qt(95)
qt(95, df=df)
qt(0.975, df=df)
dt <- length(data) -1
qt(0.975, df=df)
df <- length(data) -1
qt(0.975, df=df)
se*t(0.975)
sd(data) * qt(0.975, df=df)/sqrt(length(data))
sd(data) * qt(0.975, df=df)/sqrt(length(data))
margin <- sd(data) * qt(0.975, df=df)/sqrt(length(data))
ub <- mean(data) + margin
lb <- mean(data) - margin
up
ub
lb
medical <- read.table("MultipleRegressionData.txt")
medical <- read.table("MultipleRegressionData.txt", header = TRUE)
medical <- read.table("MultipleRegressionData.txt", header = TRUE)
cor(medical)
cor(medical)
medical <- read.table("MultipleRegressionData.txt", header = TRUE)
MEXCA_2017_output <- read.table("54_Bund_2017_output_df.csv", header = TRUE)
MEXCA_2017_output <- read.table("54_Bund_2017_output_df.csv", header = TRUE)
MEXCA_2017_output <- read.csv("54_Bund_2017_output_df.csv", header = TRUE)
MEXCA_2017_output <- read.csv("54_Bund_2017_output_df.csv")
MEXCA_2017_output <- read.table("54_Bund_2017_output_df.csv", header = TRUE)
MEXCA_2017_output <- read.csv("54_Bund_2017_output_df.csv")
setwd("/Users/JasminHagemann/Desktop/GitHub/hagemann-WeatherTripPlanner/WeatherTripPlanner")
devtools::document()
# 6. build your package
# creates an installable file with ending "tar.gz"
devtools::build()
# 7. your package can now be installed (by you and others!)
rm(list = ls())
devtools::install()
#' given as input when calling the function.
#' @param location A location in the format 'City/zip code, Country'.
#' @return A list with the coordinates (latitude and longitude) of the given location.
#' The keys of the list are "latitude" and "longitude", and their respective values
#' are the latitude and longitude coordinates extracted from the API response.
#' @examples
#' get_coordinates("Amsterdam, Netherlands")
#' get_coordinates("Berlin, Germany")
#' get_coordinates("5020, Austria")
#' @export
get_coordinates <- function(location) {
api_key <- "f64ebf508b21463287ef1fc29cbaf119"
base_url <- "https://api.opencagedata.com/geocode/v1/json"
query <- utils::URLencode(location)
request_url <- paste0(base_url, "?q=", query, "&key=", api_key)
response <- httr::GET(request_url)
# Check if the request was successful
if (httr::status_code(response) != 200) {
stop("Failed to retrieve data. Please check the location and try again.")
}
data <- jsonlite::fromJSON(httr::content(response, as = "text"))
# Check if there are results
if (length(data$results) == 0) {
stop("No results found for the given location.")
}
latitude <- data$results$geometry$lat
longitude <- data$results$geometry$lng
# Check: print extracted coordinates
# cat("Latitude:", latitude, "\n")
# cat("Longitude:", longitude, "\n")
return(list(latitude = latitude, longitude = longitude))
}
#' The default value is 2014-01-01.
#' @param end_date The end date for the weather data in the format "YYYY-MM-DD".
#' The default value is today's date.
#' @return The parsed weather data as a list.
#' @examples
#' get_weather_data("Amsterdam, Netherlands", "2014-01-01", "2014-01-02")
#' get_weather_data("Amsterdam, Netherlands")
#' get_weather_data("Tokyo, Japan", "2024-03-03", "2024-03-15")
#' get_weather_data("Tokyo, Japan")
#' @export
get_weather_data <- function(location,
start_date = "2014-01-01",
end_date = as.character(lubridate::today())) {
api_url <- "https://archive-api.open-meteo.com/v1/archive"
coordinates <- get_coordinates(location)
params <- list(
latitude = coordinates$latitude,
longitude = coordinates$longitude,
start_date = start_date,
end_date = end_date,
daily = paste(c("weather_code", "temperature_2m_max", "temperature_2m_min", "temperature_2m_mean", "daylight_duration", "sunshine_duration", "precipitation_sum", "rain_sum", "snowfall_sum", "precipitation_hours", "wind_speed_10m_max"), collapse = ",")
)
res <- httr::GET(api_url, query = params)
# Check for request success
if (httr::status_code(res) != 200) {
stop("Failed to fetch data. Status code: ", httr::status_code(res))
}
# Parse the JSON content
content <- httr::content(res, "text", encoding = "UTF-8")
weather_data <- jsonlite::fromJSON(content, flatten = TRUE)
return(weather_data)
}
#' @param start_date The start date for the weather data in the format "YYYY-MM-DD".
#' The default value is 2014-01-01.
#' @param end_date The end date for the weather data in the format "YYYY-MM-DD".
#' The default value is today's date.
#' @return A data frame with the weather data for each day in the indicated
#' time period at the given location.
#' @examples
#' process_weather_data("Tokyo, Japan", "2024-03-03", "2024-03-15")
#' process_weather_data("Amsterdam, Netherlands")
#' @export
process_weather_data <- function(location,
start_date = "2014-01-01",
end_date = as.character(lubridate::today())) {
weather_data <- get_weather_data(location, start_date, end_date)
daily <- weather_data$daily
daily_data <- data.frame(
date = seq(
as.Date("2014-01-01"),
lubridate::today(),
by = "day"
)[1:length(daily$weather_code)],
weather_code = daily$weather_code,
temperature_max = daily$temperature_2m_max,
temperature_min = daily$temperature_2m_min,
temperature_mean = daily$temperature_2m_mean,
daylight_duration = daily$daylight_duration,
sunshine_duration = daily$sunshine_duration,
precipitation_sum = daily$precipitation_sum,
rain_sum = daily$rain_sum,
snowfall_sum = daily$snowfall_sum,
precipitation_hours = daily$precipitation_hours,
wind_speed_10m_max = daily$wind_speed_10m_max
)
return(daily_data)
}
process_weather_data("Tokyo, Japan", "2024-03-03", "2024-03-15")
#' given as input when calling the function.
#' @param location A location in the format 'City/zip code, Country'.
#' @return A list with the coordinates (latitude and longitude) of the given location.
#' The keys of the list are "latitude" and "longitude", and their respective values
#' are the latitude and longitude coordinates extracted from the API response.
#' @examples
#' get_coordinates("Amsterdam, Netherlands")
#' get_coordinates("Berlin, Germany")
#' get_coordinates("5020, Austria")
#' @export
get_coordinates <- function(location) {
api_key <- "f64ebf508b21463287ef1fc29cbaf119"
base_url <- "https://api.opencagedata.com/geocode/v1/json"
query <- utils::URLencode(location)
request_url <- paste0(base_url, "?q=", query, "&key=", api_key)
response <- httr::GET(request_url)
# Check if the request was successful
if (httr::status_code(response) != 200) {
stop("Failed to retrieve data. Please check the location and try again.")
}
data <- jsonlite::fromJSON(httr::content(response, as = "text"))
# Check if there are results
if (length(data$results) == 0) {
stop("No results found for the given location.")
}
latitude <- data$results$geometry$lat
longitude <- data$results$geometry$lng
# Check: print extracted coordinates
# cat("Latitude:", latitude, "\n")
# cat("Longitude:", longitude, "\n")
return(list(latitude = latitude, longitude = longitude))
}
process_weather_data("Tokyo, Japan", "2024-03-03", "2024-03-15")
setwd("/Users/JasminHagemann/Desktop/GitHub/hagemann-WeatherTripPlanner/WeatherTripPlanner")
devtools::install()
library (WeatherTripPlanner)
process_weather_data("Tokyo, Japan", "2024-03-03", "2024-03-15")
install.packages("shiny")
install.packages("shiny")
library(shiny)
# Create a Shiny UI
ui <- fluidPage(
titlePanel("Weather App"),
selectInput("municipality", "Select municipality", municipalities),
mainPanel(
tabsetPanel(
tabPanel("Current Weather", tableOutput("current_weather")),
tabPanel("Temperature Forecast", plotlyOutput("forecast_plot"))
)
)
)
library(jsonlite)
library(httr)
library(plotly)
# Create a Shiny UI
ui <- fluidPage(
titlePanel("Weather App"),
selectInput("municipality", "Select municipality", municipalities),
mainPanel(
tabsetPanel(
tabPanel("Current Weather", tableOutput("current_weather")),
tabPanel("Temperature Forecast", plotlyOutput("forecast_plot"))
)
)
)
library(shiny)
library(shiny)
install.packages("shiny")
install.packages("shiny")
library(shiny)
library(shiny)
install.packages("shiny")
install.packages("shiny")
library(shiny)
library(jsonlite)
library(httr)
library(plotly)
# Create a vector of municipalities in Latvia
municipalities <- c("Aglona", "Aizkraukle", "Aizpute", "Akniste", "Aloja",
"Alsunga", "Aluksne", "Amata", "Ape", "Auce", "Babite",
"Baldone", "Baltinava", "Balvi", "Bauska", "Broceni",
"Carnikava", "Cesvaine", "Ciblas", "Daugavpils", "Dobele",
"Dundaga", "Durbes", "Engure", "Ergli", "Garkalne",
"Grobinas", "Gulbene", "Iecava", "Ikskile", "Ilukste",
"Incukalns", "Jaunjelgava", "Jaunpiebalga", "Jaunpils",
"Jekabpils", "Jelgava", "Jurmala", "Kandava", "Karsava",
"Kegums", "Kekava", "Koceni", "Koknese", "Kraslava",
"Krimulda", "Krustpils", "Kuldiga", "Kumene", "Lielvarde",
"Ligatne", "Limbazi", "Livani", "Lizums", "Ludza", "Madona",
"Mazsalaca", "Naukseni", "Nereta", "Nica", "Ogre", "Olaine",
"Ozolnieki", "Pargauja", "Pasvalys", "Pelcku", "Plavinas",
"Preili", "Priekuli", " Priekule", "Rauna", "Rezekne",
"Riebi", "Riga", "Rujiena", "Sabile", "Salacgriva",
"Salaspils", "Saldus", "Saulkrasti", "Seda", "Sigulda",
"Skriveri", "Skrunda", "Smiltene", "Stopini", "Strenci",
"Talsi", "Tukums", "Valka", "Valmiera", "Vandzene",
"Vecpiebalga", "Vecumnieki", "Ventspils", "Viesite",
"Vilaka", "Vilani", "Zilupe")
# Create a Shiny UI
ui <- fluidPage(
titlePanel("Weather App"),
selectInput("municipality", "Select municipality", municipalities),
mainPanel(
tabsetPanel(
tabPanel("Current Weather", tableOutput("current_weather")),
tabPanel("Temperature Forecast", plotlyOutput("forecast_plot"))
)
)
)
# Define the function to get current weather data
get_weather_data <- function(municipality) {
api_key <- "c85d8912939742411f4756c70790238e" # your valid API key
url <- paste0("http://api.openweathermap.org/data/2.5/weather?q=",municipality,",lv&appid=",api_key,"&units=metric")
data <- httr::GET(url)
data <- httr::content(data)
return(data)
}
# Define the function to get forecast weather data
get_forecast_data <- function(municipality) {
api_key <- "44a8b47e94fd6388904950fd39d5b07d" # your valid API key
url <- paste0("http://api.openweathermap.org/data/2.5/forecast?q=",municipality,",lv&appid=",api_key,"&units=metric")
data <- httr::GET(url)
data <- httr::content(data)
return(data)
}
server <- function(input, output) {
weather_data <- reactive({
if (!is.null(input$municipality)) {
get_weather_data(input$municipality)
}
})
forecast_data <- reactive({
if (!is.null(input$municipality)) {
get_forecast_data(input$municipality)
}
})
#render current weather information
output$current_weather <- renderTable({
weather_data()
})
output$forecast_plot <- renderPlotly({
#Retrieve forecast data
forecast_data <- get_forecast_data(input$municipality)
# extract temperature and date-time data
forecast_temp <- forecast_data$list$main$temp
forecast_time <- as.POSIXct(forecast_data$list$dt, origin="1970-01-01", tz="UTC")
#create plot
plot_ly(x = forecast_time, y = forecast_temp, type = 'scatter', mode = 'lines+markers') %>%
layout(title = 'Temperature Forecast')
})
}
ui <- fluidPage(
titlePanel("Weather App"),
selectInput("municipality", "Select municipality", municipalities),
mainPanel(
tabsetPanel(
tabPanel("Current Weather", tableOutput("current_weather")),
tabPanel("Forecast Weather", plotlyOutput("forecast_plot"))
)
)
)
#server
server <- function(input, output) {
output$current_weather <- renderTable({
get_weather_data(input$municipality)
})
output$forecast_plot <- renderPlotly({
#Retrieve forecast data
forecast_data <- get_forecast_data(input$municipality)
# extract temperature and date-time data
forecast_temp <- forecast_data$list$main$temp
forecast_time <- as.POSIXct(forecast_data$list$dt, origin="1970-01-01", tz="UTC")
#create plot
plot_ly(x = forecast_time, y = forecast_temp, type = 'scatter', mode = 'lines+markers') %>%
layout(title = 'Temperature Forecast')
})
}
shinyApp(ui = ui, server = server)
install.packages("shiny")
install.packages("shiny")
install.packages("weatherData")
library(shiny)
library(weatherData)
install.packages("weatherData")
shinyUI(fluidPage(
# Application title
title="Weather App!",
fluidRow(
column(2,
h4("World Wide Weather"),
wellPanel(
dateInput(inputId = 'date',
label = 'Select Date',
value = Sys.Date()
),
selectInput("select", label = h3("Select Location"),
choices = list("New York" = "NYC", "San Francisco" = "SFO", "London" = "LON")),
selectInput("year", label = h3("Select Year"),
choices = list("2016" = 2016, "2015" = 2015, "2014" = 2014),
selected = 1)
)
),
column(10,
mainPanel("Daily Weather Details over Selected Date",
tabsetPanel(
tabPanel("Temperature", plotOutput("p1")),
tabPanel("Humidity", plotOutput("p2")),
tabPanel("Wind Speed", plotOutput("p3"))
)
)
),
column(10,offset=2,
tabsetPanel("Annual Weather Details",
tabPanel("Mean Temperature", plotOutput("plot1")),
tabPanel("Minimum Temperature", plotOutput("plot2")),
tabPanel("Maximum Temperature", plotOutput("plot3"))
)   )
)
)
)
