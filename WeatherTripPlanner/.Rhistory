meme(
"https://brobible.com/wp-content/uploads/2019/11/istock-153696622.jpg",
"Are we done yet?",
"Just 89502984 more packages to install",
size = 2,3
)
meme(
"https://brobible.com/wp-content/uploads/2019/11/istock-153696622.jpg",
"Are we done yet?",
"Just 89502984 more packages to install",
size = 2, 4
)
meme(
"https://brobible.com/wp-content/uploads/2019/11/istock-153696622.jpg",
"Are we done yet?",
"Just 89502984 more packages to install",
size = 2
)
meme(
"https://brobible.com/wp-content/uploads/2019/11/istock-153696622.jpg",
"I thought I was done",
"I just had to download the 89502984th package",
size = 2
)
meme(
"https://brobible.com/wp-content/uploads/2019/11/istock-153696622.jpg",
"When I thought I was done",
"I just had to download the 89502984th package",
size = 2
)
meme(
"https://brobible.com/wp-content/uploads/2019/11/istock-153696622.jpg",
"When I thought I was done",
"I just had to download the 89502984th package",
size = 2
)
plotstock <- function(stock_symbol = "IMGN", year = "2022", file_name = "IMGN_2022"){
start_date <- paste0(year, "-01-01")
end_date <- paste0(year, "-12-31")
png(file_name)
getSymbols(stock_symbol,
auto.assign = TRUE,
from = start_date,
to = end_date)
chart_Series(Ad(get(noquote(stock_symbol))))
dev.off()
# return (png)
}
plotstock()
plotstock <- function(stock_symbol = "IMGN", year = "2022", file_name = "IMGN_2022"){
start_date <- paste0(year, "-01-01")
end_date <- paste0(year, "-12-31")
png(file_name)
getSymbols(stock_symbol,
auto.assign = TRUE,
from = start_date,
to = end_date)
stock_year <- chart_Series(Ad(get(noquote(stock_symbol))))
dev.off()
return(stock_year)
}
plotstock()
install.packages("shiny")
library (shiny)
runApp('Desktop/PIPS/shiny_example.R')
runApp('Desktop/PIPS/shiny_example_widget.R')
titanic
ChickWeight
ChickWeight
Orange
cars
titanic
titanic_train
Titanic
runApp('Desktop/PIPS/assignments/shiny_datasets.R')
runApp('Desktop/PIPS/assignments/shiny_datasets.R')
ChickWeight
runApp('Desktop/PIPS/assignments/shiny_datasets.R')
ChickWeight
ui <- fluidPage(
titlePanel("Datasets for PIPS Assignments"),
sidebarLayout(
# Sidebar panel for inputs
sidebarPanel(
# Input: Select a dataset
selectInput("dataset", "Choose a dataset:",
choices = c("Trees", "Orange","ToothGrowth",
"ChickWeight", "Cars", "Titanic")),
# Input: Specify the number of observations to view
numericInput("obs", "Number of observations to view:", 10),
# Include clarifying text
helpText("Note: The summary is based on the full dataset",
"independent of indicated number of observations"),
# Input: actionButton() to defer the rendering of output
# until the user explicitly clicks the button.
actionButton("update", "Update View")
),
# Main panel for displaying outputs
mainPanel(
# Output: Header + summary of distribution
h4("Summary"),
verbatimTextOutput("summary"),
# Output: Header + table of distribution
h4("Observations"),
tableOutput("view")
)
)
)
d=data.frame(sex=c("m","f"),nr=1:40,score1=rnorm(40,0.5,1),score2=rnorm(40))
t.test?
?t.test
set.seed(1)
d=data.frame(sex=c("m","f"),nr=1:40,score1=rnorm(40,0.5,1),score2=rnorm(40))
# Subset the data for men and women
men_scores <- d$score1[d$sex == "m"]
women_scores <- d$score1[d$sex == "f"]
# Perform one-sided t-test
t_test_result <- t.test(men_scores, women_scores, alternative = "greater")
# Print the test result
print(t_test_result)
# Perform t-test using general linear model approach
t_test_result <- t.test(score1 ~ 1 + sex, data = d, alternative = "greater")
# Print the test result
print(t_test_result)
# Perform t-test using general linear model approach
t_test_result <- t.test(score1 ~ 1 + sex, data = d, alternative = "less")
# Print the test result
print(t_test_result)
t.test(score1 ~ sex,alternative="less", data=d)
t.test(score1 ~ sex,alternative="less", data=d)
t.test(score1 ~ sex,alternative="less", data=d)
data = c(36,40,47,53,26,45,52,38,46,44,36,54,54,49,57,47,29,36,29,37)
t.test(d$score1, d$score2,alternative="two.sided")
t.test(d$score1, d$score2,alternative="two.sided")
t.test(d$score1, d$score2,alternative="two.sided")
mean(data)
sd(data)
qt(data)
length(data)
qt(0.975, df = length(data) - 1)
(se*t(0.975))
t = qt(0.975, df = length(data) - 1)
se*t(0.975)
standard_deviation <- sd(data)
## Calculate the sample size
sample_size <- length(data)
## Calculate the standard error
SE <- standard_deviation / sqrt(sample_size)
## Calculate the margin of error using the critical t-value
critical_t_value <- qt(0.975, df = sample_size - 1)
margin_of_error <- SE * critical_t_value
sample_mean <- mean(data)
# Calculate the lower bound of the confidence interval
lower_bound <- sample_mean - margin_of_error
# Calculate the upper bound of the confidence interval
upper_bound <- sample_mean + margin_of_error
a <- t(x) * x
x <- c(3,4,6,8,8)
a <- t(x) * x
a
x_1 <- c(3,4,6,8,8)
x_2 <- c(2,6,4,7,7)
y <- c(4,3,5,6,9)
X_matrix <- matrix(cbind(rep(1,5), x_1, x_2), ncol = 3)
X <- matrix(cbind(rep(1,5), x_1, x_2), ncol = 3)
t(X) * X
x_1 <- c(3,4,6,8,8)
x_2 <- c(2,6,4,7,7)
y <- c(4,3,5,6,9)
X <- matrix(cbind(rep(1,5), x_1, x_2), ncol = 3)
t(X) %*% X
t(X) %*% y
XTX <- t(X) %*% X
XTY <- t(X) %*% y
beta <- slove(XTX) %*% XTY
beta <- solve(XTX) %*% XTY
beta
health <- read.table("health.txt", header = TRUE)
health <- read.table("health.txt", header = TRUE)
fit <- lm(y ~ x_1 + x_2)
fit
summary(fit)
predict(fit)
yhat <- predict(fit)
s2 <- (t(y-yhat) %*% (y-yhat))
s2
sqrt
sqrt(s2)
s2 <- (t(y-yhat) %*% (y-yhat)) / (5-2-1)
sqrt(s2)
set.seed(1)
d=data.frame(sex=c("m","f"),nr=1:40,score1=rnorm(40,0.5,1),score2=rnorm(40))
View(d)
t.test(d$score1[d$sex == "m"],d$score1[d$sex == "f"], alternative = "greater")
t.test(score1 ~sex, data = d)
t.test(score1 ~sex, alternative = "less", data = d)
t.test(d$score1, d$score2, alternative = "equal")
t.test(d$score1, d$score2)
data = c(36,40,47,53,26,45,52,38,46,44,36,54,54,49,57,47,29,36,29,37)
data = c(36,40,47,53,26,45,52,38,46,44,36,54,54,49,57,47,29,36,29,37)
mean(data)
sd(data)
qt(95)
qt(95, df=df)
qt(0.975, df=df)
dt <- length(data) -1
qt(0.975, df=df)
df <- length(data) -1
qt(0.975, df=df)
se*t(0.975)
sd(data) * qt(0.975, df=df)/sqrt(length(data))
sd(data) * qt(0.975, df=df)/sqrt(length(data))
margin <- sd(data) * qt(0.975, df=df)/sqrt(length(data))
ub <- mean(data) + margin
lb <- mean(data) - margin
up
ub
lb
medical <- read.table("MultipleRegressionData.txt")
medical <- read.table("MultipleRegressionData.txt", header = TRUE)
medical <- read.table("MultipleRegressionData.txt", header = TRUE)
cor(medical)
cor(medical)
medical <- read.table("MultipleRegressionData.txt", header = TRUE)
MEXCA_2017_output <- read.table("54_Bund_2017_output_df.csv", header = TRUE)
MEXCA_2017_output <- read.table("54_Bund_2017_output_df.csv", header = TRUE)
MEXCA_2017_output <- read.csv("54_Bund_2017_output_df.csv", header = TRUE)
MEXCA_2017_output <- read.csv("54_Bund_2017_output_df.csv")
MEXCA_2017_output <- read.table("54_Bund_2017_output_df.csv", header = TRUE)
MEXCA_2017_output <- read.csv("54_Bund_2017_output_df.csv")
library(shiny); runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
ranked_intervals <- rank_intervals_temp(7, "Augsburg, Germany", season = "Spring", temp_pref = "Warm")
ranked_intervals <- rank_intervals_temp(7, "Augsburg, Germany", season = "Spring", temp_pref = "warm")
View(ranked_intervals)
intervals <- generate_intervals(7, "Augsburg, Germany", season = "Spring")
intervals
View(intervals)
View(ranked_intervals)
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
get_coordinates("5020, Austria")
get_weather_data("Tokyo, Japan", "2024-03-03", "2024-03-15")
runApp('Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
setwd("/Users/JasminHagemann/Desktop/GitHub/hagemann-WeatherTripPlanner/WeatherTripPlanner")
devtools::install()
library (WeatherTripPlanner)
process_weather_data("Tokyo, Japan", "2024-03-03", "2024-03-15")
devtools::document()
devtools::build()
runApp('~/Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('~/Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('~/Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
runApp('~/Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
devtools::document()
devtools::document()
devtools::build()
# functions for weather trip planner
#' @title Get Coordinates
#' @description
#' get_coordinates is used to get the latitude and longitude of any location
#' given as input when calling the function.
#' @param location A location in the format 'City/zip code, Country'.
#' @return A list with the coordinates (latitude and longitude) of the given location.
#' The keys of the list are "latitude" and "longitude", and their respective values
#' are the latitude and longitude coordinates extracted from the API response.
#' @examples
#' get_coordinates("Amsterdam, Netherlands")
#' get_coordinates("Berlin, Germany")
#' get_coordinates("5020, Austria")
#' @export
get_coordinates <- function(location) {
api_key <- "f64ebf508b21463287ef1fc29cbaf119"
base_url <- "https://api.opencagedata.com/geocode/v1/json"
query <- utils::URLencode(location)
request_url <- paste0(base_url, "?q=", query, "&key=", api_key)
response <- httr::GET(request_url)
# Check if the request was successful
if (httr::status_code(response) != 200) {
stop("Failed to retrieve data. Please check the location and try again.")
}
data <- jsonlite::fromJSON(httr::content(response, as = "text"))
# Check if there are results
if (length(data$results) == 0) {
stop("No results found for the given location.")
}
latitude <- data$results$geometry$lat[1]
longitude <- data$results$geometry$lng[1]
return(list(latitude = latitude, longitude = longitude))
}
#' @title Get Weather Data
#' @description
#' get_weather_data is used to retrieve historical weather data from the
#' Open-Meteo API for a specific location and date range.
#' @param location A location in the format 'City/zip code, Country'.
#' @param start_date The start date for the weather data in the format "YYYY-MM-DD".
#' The default value is 2014-01-01.
#' @param end_date The end date for the weather data in the format "YYYY-MM-DD".
#' The default value is today's date.
#' @return The parsed weather data as a list.
#' @examples
#' get_weather_data("Amsterdam, Netherlands", "2014-01-01", "2014-01-02")
#' get_weather_data("Amsterdam, Netherlands")
#' get_weather_data("Tokyo, Japan", "2024-03-03", "2024-03-15")
#' get_weather_data("Tokyo, Japan")
#' @export
get_weather_data <- function(location,
start_date = "2014-01-01",
end_date = as.character(lubridate::today())) {
api_url <- "https://archive-api.open-meteo.com/v1/archive"
coordinates <- get_coordinates(location)
params <- list(
latitude = coordinates$latitude,
longitude = coordinates$longitude,
start_date = start_date,
end_date = end_date,
daily = paste(c("weather_code", "temperature_2m_max", "temperature_2m_min", "temperature_2m_mean", "daylight_duration", "sunshine_duration", "precipitation_sum", "rain_sum", "snowfall_sum", "precipitation_hours", "wind_speed_10m_max"), collapse = ",")
)
res <- httr::GET(api_url, query = params)
# Check for request success
if (httr::status_code(res) != 200) {
stop("Failed to fetch data. Status code: ", httr::status_code(res))
}
content <- httr::content(res, "text", encoding = "UTF-8")
weather_data <- jsonlite::fromJSON(content, flatten = TRUE)
return(weather_data)
}
#' @title Process Weather Data
#' @description
#' process_weather_data processes the data which was retrieved with the
#' get_weather_data function and creates a new data frame with the daily weather data.
#' @param location A location in the format 'City/zip code, Country'.
#' @param start_date The start date for the weather data in the format "YYYY-MM-DD".
#' The default value is 2014-01-01.
#' @param end_date The end date for the weather data in the format "YYYY-MM-DD".
#' The default value is today's date.
#' @return A data frame with the weather data for each day in the indicated
#' time period at the given location.
#' @examples
#' process_weather_data("Tokyo, Japan", "2024-03-03", "2024-03-15")
#' process_weather_data("Amsterdam, Netherlands")
#' @export
process_weather_data <- function(location,
start_date = "2014-01-01",
end_date = as.character(lubridate::today())) {
weather_data <- get_weather_data(location, start_date, end_date)
daily <- weather_data$daily
daily_data <- data.frame(
date = seq(
as.Date(start_date),
as.Date(end_date),
by = "day"
)[1:length(daily$weather_code)],
weather_code = daily$weather_code,
temperature_max = daily$temperature_2m_max,
temperature_min = daily$temperature_2m_min,
temperature_mean = daily$temperature_2m_mean,
daylight_duration = daily$daylight_duration,
sunshine_duration = daily$sunshine_duration,
precipitation_sum = daily$precipitation_sum,
rain_sum = daily$rain_sum,
snowfall_sum = daily$snowfall_sum,
precipitation_hours = daily$precipitation_hours,
wind_speed_10m_max = daily$wind_speed_10m_max
)
return(daily_data)
}
#' @title Filter Weather Data
#' @description filter_by_season filters a data frame by the indicated season.
#' @param location A location in the format 'City/zip code, Country'.
#' @param start_date The start date for the weather data in the format "YYYY-MM-DD".
#' The default value is 2014-01-01.
#' @param end_date The end date for the weather data in the format "YYYY-MM-DD".
#' The default value is today's date.
#' @param season A season (winter, spring, summer, fall).
#' @return a filtered data frame containing the original data for all of the months
#' of the indicated season.
#' @examples
#' filter_by_season("Munich, Germany", "2023-01-10", "2024-05-15", "Spring")
#' filter_by_season("Leiden, Netherlands", season = "Summer")
#' filter_by_season("08001, Spain", season = "Winter")
#' @export
filter_by_season <- function(location,
start_date = "2014-01-01",
end_date = as.character(lubridate::today()),
season) {
df <- process_weather_data(location, start_date, end_date)
if (!inherits(df[[1]], "Date")) {
df[[1]] <- as.Date(df[[1]], format = "%Y-%m-%d")
}
df$Month <- format(df[[1]], "%m")
seasons <- list(
Winter = c("12", "01", "02"),
Spring = c("03", "04", "05"),
Summer = c("06", "07", "08"),
Fall = c("09", "10", "11")
)
# Check if the input season is valid
if (!season %in% names(seasons)) {
stop("Invalid season. Choose from 'Winter', 'Spring', 'Summer', or 'Fall'.")
}
filtered_df <- df[df$Month %in% seasons[[season]], ]
filtered_df$Month <- NULL
return(filtered_df)
}
#' @title Consecutive Day Intervals with Average Weather Parameters
#' @description generate_intervals creates all possible intervals of
#' consecutive days based on the specified number of days. The intervals contain
#' the averages of the weather parameters for all days of the months in the indicated season.
#' @param num_days The number of consecutive days in each interval.
#' @param location A location in the format 'City/zip code, Country'.
#' @param start_date The start date for the weather data in the format "YYYY-MM-DD".
#' The default value is 2014-01-01.
#' @param end_date The end date for the weather data in the format "YYYY-MM-DD".
#' The default value is today's date.
#' @param season A season (winter, spring, summer, fall).
#' @return A data frame containing all possible intervals of consecutive days
#' with the average weather parameters.
#' @examples
#' generate_intervals(5, "Munich, Germany", "2023-01-10", "2024-05-15", "Spring")
#' generate_intervals(7, "Leiden, Netherlands", season = "Summer")
#' generate_intervals(3, "08001, Spain", season = "Winter")
#' @export
generate_intervals <- function(num_days,
location,
start_date = "2014-01-01",
end_date = as.character(lubridate::today()),
season) {
filtered_df <- filter_by_season(location, start_date, end_date, season)
filtered_df$date <- format(filtered_df$date, "%m-%d")
all_intervals <- lapply(1:(nrow(filtered_df) - num_days + 1), function(i) filtered_df[i:(i + num_days - 1), ])
return(all_intervals)
}
#' @title Rank Intervals by Temperature
#' @description rank_intervals_temp ranks the intervals based on temperature preference.
#' @param intervals A list of data frames containing intervals of consecutive days with weather data.
#' @param temp_pref The ranking criteria: "warm" to rank by highest temperature or "cold" to rank by lowest temperature.
#' @return A list of ranked intervals based on temperature criteria.
#' @examples
#' rank_intervals_temp(5, "Munich, Germany", "2023-01-10", "2024-05-15", "Spring", "warm")
#' rank_intervals_temp(7, "Amsterdam, Netherlands", "2024-01-01", "2024-01-10", "Winter", "cold")
#' rank_intervals_temp(7, "Milan, Italy", "2024-01-01", "2024-03-01", "Winter", "cold")
rank_intervals_temp <- function(num_days,
location,
start_date = "2014-01-01",
end_date = as.character(lubridate::today()),
season,
temp_pref) {
intervals <- generate_intervals(num_days, location, start_date, end_date, season)
mean_temperatures <- sapply(intervals, function(interval) mean(interval$temperature_mean))
if (temp_pref == "warm") {
ranked_intervals <- intervals[order(mean_temperatures, decreasing = TRUE)]
} else if (temp_pref == "cold") {
ranked_intervals <- intervals[order(mean_temperatures)]
} else {
stop("Invalid rank criteria. Choose from 'warm' or 'cold'.")
}
return(ranked_intervals)
}
#' @title Rank Intervals by Precipitation
#' @description rank_intervals_temp first calculates the total precipitation,
#' snowfall, and rain for each interval. It then ranks the intervals based on
#' the specified precipitation preference ("none", "snow", or "rain")
#' @param intervals A list of data frames containing intervals of consecutive days with weather data.
#' @param precip_pref The ranking criteria: "none", "snow", or "rain".
#' @return A list of ranked intervals based on the precipitation preference.
#' @examples
#' rank_intervals_precip(5, "Munich, Germany", "2023-01-10", "2024-05-15", "Spring", "none")
#' rank_intervals_precip(7, "Amsterdam, Netherlands", "2024-01-01", "2024-01-10", "Winter", "snow")
#' rank_intervals_precip(7, "Milan, Italy", "2024-01-01", "2024-03-01", "Winter", "rain")
rank_intervals_precip <- function(num_days,
location,
start_date = "2014-01-01",
end_date = as.character(lubridate::today()),
season,
precip_pref) {
intervals <- generate_intervals(num_days, location, start_date, end_date, season)
total_precip <- sapply(intervals, function(interval) sum(interval$precipitation_sum))
total_snow <- sapply(intervals, function(interval) sum(interval$snowfall_sum))
total_rain <- sapply(intervals, function(interval) sum(interval$rain_sum))
if (precip_pref == "none") {
ranked_intervals <- intervals[order(total_precip)]
} else if (precip_pref == "snow") {
ranked_intervals <- intervals[order(total_snow, decreasing = TRUE)]
} else if (precip_pref == "rain") {
ranked_intervals <- intervals[order(total_rain, decreasing = TRUE)]
} else {
stop("Invalid precipitation preference. Choose from 'none', 'snow', or 'rain'.")
}
return(ranked_intervals)
}
generate_intervals(5, "Munich, Germany", "2023-01-10", "2024-05-15", "Spring")
#' @examples
runApp('~/Desktop/GitHub/hagemann-WeatherTripPlanner/shiny_app.R')
